没什么好说的，唯一一个小点就是注意回文串也可以关于字符中的间隔对称，每次中心移动0.5个位子就可以解决。是O（n^2）的算法，准备学一下O(n)的马拉车算法
#include<iostream>
#include<string>
using namespace std;
int main() {
	while (1) {
		string s;
		cin >> s;
		int len = s.size();
		string ans;
		int maxl=0;
		
		for (float i = 0; i <= len-1; i+=0.5) {
			int ext = 0;
			for (; ceil(i - ext) >= 0 && floor(i + ext) < len&&s[ceil(i - ext)] == s[floor(i + ext)]; ext++);
			ext--;
			if (int(i) == i) {
				if (ext * 2 + 1 > maxl) {
					maxl = ext * 2 + 1;
					ans = s.substr(i - ext, ext * 2 + 1);
				}
			}
			else
			{
				if (ext * 2 > maxl) {
					maxl = ext * 2;
					ans = s.substr(ceil(i - ext), ext * 2);
				}
			}

		}
		cout << ans << endl;
	}
}
