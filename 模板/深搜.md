二年前接触过八皇后问题一次，当时想花一晚上搞定来着，但是当时觉得太难就作罢了，最后只是把为了熬夜准备的零食给吃了一半...
anyway,这次再写，感觉其实不是很难。无非就是递归循环实现搜索再加一定的剪枝。听名字很高大上，其实想清楚了没什么。重点还是在于对于问题条  
件的判断和理解。
现在想想，如果当时再勇敢一点，不要因为觉得自己不厉害而逃避算法，或许现在会不太一样吧。不过现在意识到了，还好不算太晚，冲冲冲！

下面是八皇后的代码（输出前三个解和所有解的个数）
```cpp
#include<iostream>
using namespace std;

const int maxn = 14;
int ans[maxn] = {0}, chk[3][2 * maxn], sum = 0, n;
//search
void dfs(int row){
	
	if(row > n){
		sum++;
		if(sum <= 3){
			for(int i = 1; i <= n; i++)
				cout<< ans[i]<< " ";
			cout << endl;
		}
		return;
	}
	else{
		for(int i = 1; i <= n; i++){
			if(!chk[0][i] && !chk[1][row + i] && !chk[2][row - i + n]){
				ans[row] = i;
				chk[0][i] = chk[1][row + i] = chk[2][row - i + n] = 1;
				dfs(row + 1);
				chk[0][i] = chk[1][row + i] = chk[2][row - i + n] = 0;


			}
		}
	}
}

int main(){
	cin >> n;
	dfs(1);
	cout << sum << endl;
	

}

```
