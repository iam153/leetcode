pat1020 给定二叉树后序和中序，求前序
```cpp
node* create(int inL, int inR, int postL, int postR) {
	if (postL > postR)
		return NULL;
	node* root = new node;
	root->val = post[postR];
	int k;
	for (k = inL; k <= inR; k++)
		if (in[k] == post[postR])
			break;
	int nL = k - inL;
	root->left = create(inL, k - 1, postL, postL + nL - 1);
	root->right = create(k + 1, inR, postL + nL, postR - 1);

	return root;

}

```

pat1086 给定二叉树前序和中序，求后序

```cpp
node* create(int preL, int preR, int inL, int inR) {
	if (preL > preR)
		return NULL;

	node* rt = new node;
	rt->val = pre[preL];
	int k;
	for (k = inL; k < inR; k++)
		if (in[k] == pre[preL])
			break;
	int nL = k - inL;
	rt->le = create(preL + 1, preL + nL, inL, k - 1);
	rt->ri = create(preL + nL + 1, preR, k + 1, inR);
	return rt;
}

```
 
 ```cpp
 //给定层序和中序，求前序
 //重点在于找出层序中首个在中序中出现的值，这个值就是当前树的根
 node* create(int inL, int inR, int leL, int leR) {
	if (inL > inR)
		return NULL;
	node* rt = new node;
	int i, j;
	for (i = leL; i <= leR; i++) {
		for (j = inL; j <= inR; j++)
			if (le[i] == in[j])
				break;
		if (j != inR + 1)
			break;
	}
	rt->val = le[i];
	rt->le = create(inL, j - 1, i + 1, leR);
	rt->ri = create(j + 1, inR, i + 1, leR);
	return rt;
}
 
 ```
